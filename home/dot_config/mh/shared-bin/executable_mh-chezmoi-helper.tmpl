#!/usr/bin/env zsh
# shellcheck shell=bash

# Commands related to chezmoi for use in zsh, mainly to help detect when chezmoi
# has been applied since zsh was last loaded.
#
# To use:
# (1) wrap calls to chezmoi apply with:
#       mh-chezmoi-helper apply
# (2) from your starship.toml, call this with when=true:
#       mh-chezmoi-helper starship_prompt
# (3) add the following to your .zshrc:
#       eval "$(mh-chezmoi-helper shell_init)"
#
# See show_syntax function below for usage.

share_dir="${MH_SHARE_DIR:-$HOME/.local/share/mh}"
last_applied_path="$share_dir"/.chezmoi-last-applied
last_clean_applied_path="$share_dir"/.chezmoi-last-clean-applied
source_dir="{{ .chezmoi.sourceDir }}/.." # sourceDir is 'home' dir in the repo

function show_syntax {
  echo "Syntax: $0 <command> [<args>]" >&2
  echo "Commands:" >&2
  echo " apply" >&2
  echo " starship_prompt" >&2
  echo " shell_init" >&2
}

# Echoes last modified time of the given file in epoch seconds, else "0".
function get_last_modified {
  local file="$1"
  if [[ ! -f "$file" ]]; then
    echo "0"
  fi
  if [[ "$(uname -s)" == "Darwin" ]]; then
    stat -f "%m" "$file"
  elif [[ "$(uname -s)" == "Linux" ]]; then
    stat -c %Y "$file"
  else
    echo "Unsupported OS: $(uname -s)" >&2
    echo "0"
  fi
}

# Wraps a call to chezmoi apply with updates to the last
# applied time and last clean applied time.
function apply {
  if [[ ! -f "$last_applied_path" ]]; then
    mkdir -p "$(dirname "$last_applied_path")"
  fi
  touch "$last_applied_path"

  chezmoi apply "$@"
  result_code=$?

  if [[ "$result_code" -eq 0 ]]; then
    # Store the HEAD ref in file contents, and current time via file mod time
    git -C "$source_dir" rev-parse HEAD > "$last_clean_applied_path" || true
  fi
  return "$result_code"
}

# Show if chezmoi source and target are out of sync
function show_needs_apply {
  local num_changes
  num_changes="$(chezmoi status | wc -l | awk '{print $1}')"
  if [[ "$num_changes" -gt 0 ]]; then
    echo -n "️A(${num_changes})"
  fi
}

# Show if chezmoi repo is dirty
function show_git_status {
  local num_changes
  num_changes="$(git -C "$source_dir" status --porcelain | wc -l | awk '{print $1}')"
  if [[ "$num_changes" -gt 0 ]]; then
    echo -n "️D(${num_changes})"
  fi
}

# Show if chezmoi repo is on a branch other than dev or main
function show_unexpected_branch {
  current_branch="$(git -C "$source_dir" branch --show-current)"
  if [[ "$current_branch" != "dev" && "$current_branch" != "main" ]]; then
    echo -n "B(${current_branch})"
  fi
}

# Echoes a status indicator if chezmoi has been applied since zsh was loaded,
# and a terse error if shell not initialised properly.
function show_reload_status {
  local current_last_applied

  if [[ -z "$MH_CHEZMOI_LOADED_VERSION" ]]; then
      echo "[mh-chezmoi-helper shell_init required]"
      return
  fi

  current_last_applied="$(get_last_modified "$last_applied_path")"

  if [[ "$current_last_applied" -gt "$MH_CHEZMOI_LOADED_VERSION" ]]; then
      seconds=$((current_last_applied - MH_CHEZMOI_LOADED_VERSION))
      if [[ "$seconds" -lt 60 ]]; then
        the_diff="${seconds}s"
      elif [[ "$seconds" -lt 3600 ]]; then
        the_diff="$((seconds / 60))m"
      else
        the_diff="$((seconds / 3600))h"
      fi
      echo -n "R(${the_diff})"
  fi
}

function starship_prompt {
  local needs_apply
  local git_status
  local unexpected_branch
  local reload_status

  needs_apply="$(show_needs_apply)"
  git_status="$(show_git_status)"
  unexpected_branch="$(show_unexpected_branch)"
  reload_status="$(show_reload_status)"

  combined="${needs_apply}${git_status}${unexpected_branch}${reload_status}"

  if [[ -n "$combined" ]]; then
    echo -n "[🏠${combined}]"
  fi
}

# When evaluated, records the last chezmoi apply time in an environment variable.
function shell_init {
  local last_applied
  last_applied="$(get_last_modified "$last_applied_path")"
  echo "export MH_CHEZMOI_LOADED_VERSION=$last_applied"
}

command="$1"

case "$command" in
  apply)
    shift
    apply "$@"
    ;;
  starship_prompt)
    starship_prompt
    ;;
  shell_init)
    shell_init
    ;;
  *)
    echo "Unknown command: $command" >&2
    show_syntax
    exit 1
    ;;
esac
